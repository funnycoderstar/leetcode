## 刷算法的技术目录

-   [leetcode-剑指 offer](https://leetcode-cn.com/study-plan/lcof/?progress=9ocd5ht)
-   [leetcode-初级算法](https://leetcode-cn.com/leetbook/detail/top-interview-questions-easy/)

## 二叉树题目

-   刷一道算法题：https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA
    -   [二叉树](https://mp.weixin.qq.com/s/izZ5uiWzTagagJec6Y7RvQ)
    -   翻转二叉树 ✅
    -   二叉树有多少个节点

## 笔记

二叉树的重要性，很多算法都可以扯上二叉树。二叉树的前中后序遍历框架。
比如经典算法，快速排序，归并排序

二叉树的难点：如果把题目的要求细化成每个节点要做的事情。这种洞察力需要多刷题训练。

做题步骤：理解清楚题目意思 -> 思考实现思路 -> 写代码验证

二叉树的类型

-   完美二叉树
-   二叉搜索树

思路上的误区：
每次都想想一个完整且完美的解决方案，这大概需要大量的练习之后，就是凭借经验去看这个题目怎么解决。
但是在初期锻炼思路的时候，是要一点点地去分步骤去解决问题的，比如想到一个方案，就去尝试，有问题就再想办法解决新的问题

## 算法题框架

总结，提炼，理解框架。可以帮助你做到，在快睡着的时候，依然能写出正确的程序。
只要是递归的问题就是树的问题。

数据的存储方式，基本就是链式（链表）和顺序（数据）两种，基本操作就是增删改查，遍历方式就是迭代和递归。
建议从树的分类开始刷，结合框架，刷了几十道，差不多就理解到位了。然后再去看回溯，动态规划，分治，就清晰多了。

## 二叉树题目框架

所有回溯，动态规划，分治算法都是树的问题。
快速排序是二叉树的前序遍历。归并排序就是个二叉树的后序遍历

二叉树的递归遍历框架，前中后序遍历

```js
/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

递归解法应该是最简单，最容易理解的。行云流水写好递归是学算法的基本功。二叉树题目最练习递归基本功。

### 递归算法的秘诀：

1. 明确递归函数的定义是什么，然后相信这个定义，根据这个定义推导最终结果，绝不要试图跳入递归。
   我就是总跳入递归，然后最后就是头疼到怀疑自己的能力，最后一点都不想刷题了，因为每次做题都在提醒自己到底有多菜，没有正向反馈，没有积极的自信的成功的体验，然后就恶性循环了。
2. 先搞清楚当前节点 root 应该做什么，然后根据函数定义递归调用子节点。递归调用会让子节点做相同的事。

二叉树的难点在于：如果把题目要求细化到每个节点要做的事，然后根据题目要求选择前，中，后序遍历框架。这个需要刷题多加练习。
做完一个题目，就反过来套一下框架。比如翻转二叉树：就是把二叉树上每个节点的左右节点交换。

## 排序

### 冒泡排序：相邻两个元素两两比较，当一个元素大于右侧相临元素时，交换他们的问题。

由于该排序算法的每一轮都要遍历所有的元素，总共遍历（元素个数-1）轮，平均时间复杂度为 O(n^2)

使用双循环排序，外层循环控制遍历多少轮，内层循环负责实现每一轮的气泡交换（两个元素比较，然后交换）

```js
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

基于冒泡排序的优化。
针对数组中大部分有序的情况，加一个条件判断，减少循环的轮数。

## 快速排序

比冒泡排序快，使用了分治法。
每一轮挑一个基准元素，并让其他比它大的元素移动到数列一遍，比它小的移动到另一边，将数列拆成两个部分。

写法一：
开辟两个单独的存储空间 `left`和 `right`来存储每次递归和 target 小和大的序列。

每次递归直接返回 `left 、target、right` 拼接后的数组。
浪费大量存储空间，写法简单

```js
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    let mid = Math.floor(arr.length / 2);
    var midValue = arr.splice(mid, 1)[0];
    let left = [];
    let right = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] < midValue) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }

    return quickSort(left).concat([midValue], quickSort(right));
}
```

写法二：
不需要额外存储空间，写法思考稍复杂
